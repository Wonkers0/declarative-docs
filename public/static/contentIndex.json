{"advanced/advanced-components":{"title":"Advanced Components","links":["key-change"],"tags":[],"content":"For more complex component relationships, the declarative offers a more extensive function, createAdvancedComponent. This allows you to specify 2 more parameters about the\r\nbehavior of the component. Let‚Äôs take a look:\n\nThis allows us to create a component that inherits the event implementations of another (or pass an empty string if you do not wish to inherit anything), as well as enable the tick event for specific component instances, which will fire every tick.\nFor instance, imagine that we had an npc component, which would spawn a villager with no AI and update the component key using the Key Change Pattern. We could then create a merchant component that inherits the npc component and adds some inventory menu functionality:\nPlayerEvent(Join) {\n  CallFunction(__init)\n  CallFunction(createComponent, &quot;npc&quot;, new Location(25.5, 50.5, 69.5))\n  // Create an unticked &quot;merchant&quot; component that inherits the &quot;npc&quot; component events:\n  CallFunction(createComponent, &quot;merchant&quot;, &quot;npc&quot;, 0, new Location(22.5, 50.5, 69.5))\n}\n \nFunction(&quot;npc:init&quot;) {\n  SpawnMob(SpawnEgg(Villager), Variable(loc, LOCAL), &quot;&lt;#bf7e45&gt;NPC&quot;)\n  SetAI(None)\n  CallFunction(setComponentKey, GameValue(UUID, LastEntity))\n}\n \nFunction(&quot;merchant:init&quot;) {\n  // Select the villager spawned in the npc:init event now that the key has changed\n  SelectEntity(Variable(uuid, LOCAL))\n  SetName(&quot;&lt;#bf7e45&gt;MERCHANT&quot;)\n  SetVillagerBiome(&quot;Taiga&quot;)\n}\n \nFunction(&quot;merchant:onClickEntity&quot;) {\n  ShowInv(...)\n  PlaySound(&quot;Wandering Trader Disappear&quot;, 1, 2)\n}\n\n\n                  \n                  Viewing Examples Live \n                  \n                \n\nTo view the results of the snippet above, run @e4 to view the example above on plot 60983\n\n"},"advanced/custom-events":{"title":"Custom Events","links":[],"tags":[],"content":"\n\n                  \n                  Todo\n                  \n                \n\nThis part of the documentation still needs to be written üòî\r\nMaybe make a PR?\n\n"},"advanced/extraction":{"title":"Component Info Extraction","links":[],"tags":[],"content":"\n\n                  \n                  Todo\n                  \n                \n\nThis part of the documentation still needs to be written üòî\r\nMaybe make a PR?\n\n"},"advanced/index":{"title":"Advanced","links":[],"tags":[],"content":""},"advanced/parent-child":{"title":"Parent-Child Component Relationships","links":[],"tags":[],"content":"\n\n                  \n                  Todo\n                  \n                \n\nThis part of the documentation still needs to be written üòî\r\nMaybe make a PR?\n\n"},"basics":{"title":"Getting Started","links":["key-change"],"tags":[],"content":"Installation / Set-up\nYou can grab the latest version of the library from plot 60983 (/join 60983). It will give you 2 shulker boxes, which you need to hold in one of your saved hotbars. Then, you can go onto your own plot and place the templates in the shulker boxes. I recommend placing them at the very top of your codespace (/p codespace add tinted -c 40) and then removing all of the codespaces below the declarative library by flying directly underneath the layer on which you placed the bottom-most library thread and running /p codespace remove 40.\nThen, to initialize the library, simply call the __init function in your Join event.\n\n\n                  \n                  Common Pitfall \n                  \n                \n\nAll internal functions are hidden in the call function menu and prefixed with __, so when calling __init, you have to right click the call function block sign with a\nstring that has the function name. You won‚Äôt be able to pick it from the menu by regularly right clicking the sign.\n\n\nCreating components\nComponents are abstractions of things in your game. The library makes no assumption as to what these ‚Äúthings‚Äù are. It‚Äôs up to you to give logic to an otherwise vacant component. Let‚Äôs look at how they work.\nTo create a component simply call createComponent. It accepts the following arguments:\n\n\nname: The name of the component. This is analogous to class names in OOP.\nkey: This is used to fire component events, but does not serve as a unique identifier of the component instance; you can have 2 components with the same key. We‚Äôll look more into this soon.\nprops: This is a plural argument that forms a list of values that can be accessed and modified from within the component. If omitted, the component will be instantiated with an empty list as its props.\n\nComponent events\nEvents are functions that run in a vacuum (separate thread) for each component. For instance, all components will have an init event. This is called when the component is created, and allows you to run any initialization logic, such as spawning entities and the like. Let‚Äôs try it with an example:\nPlayerEvent(Join) {\n  CallFunction(__init)\n  CallFunction(createComponent, &quot;my_component&quot;, &quot;&quot;) // If you don&#039;t wish to have a key,\n                                                    // you can pass an empty string.\n}\n \nFunction(my_component:init) {\n  SendMessage(&quot;I have been created! My ID is: &quot;, Variable(componentId, LOCAL))\n}\n \n// üíæ Output:\n// I have been created! My ID is: i3upoxy2dw\n\n\n                  \n                  Viewing Examples Live \n                  \n                \n\nFor a better experience, run @e1 to view the example above on plot 60983\n\n\nComponent info variables\nIn all component event threads, you have access to the following local variables:\n\ncomponentId: Unique identifier of this component instance; assigned by the library\nloc/uuid: The value of the component‚Äôs key; loc if you passed a location, uuid if you passed a string.\nprops: A list with the component‚Äôs properties\n\nKeys and events\nAs previously mentioned, keys are used to fire component events related to things that happen in your game. For instance, passing a location as the key will give you access\nto the onStep event, which will fire every tick that a player is standing on the block at that location:\nPlayerEvent(Join) {\n  CallFunction(__init)\n  CallFunction(createComponent, &quot;win_zone&quot;, new Location(12.5, 50.5, 42.5))\n}\n \nFunction(&quot;win_zone:onStep&quot;) {\n  SendTitle(&quot;&quot;, &quot;&lt;#8cb85a&gt;You win!&quot;, 20, 0, 10)\n  PlaySound(&quot;Pling&quot;, 1, 2)\n}\n \n// üé¨ Result:\n// Standing on the gold block will continuously\n// send a subtitle every tick.\n\n\n                  \n                  Viewing Examples Live \n                  \n                \n\nFor a better experience, run @e2 to view the example above on plot 60983\n\n\nProps\nProps allow us to preserve state throughout the component‚Äôs lifespan. In other words, props allow you to store data that is specific to each component instance.\nIn our previous example, we had a win zone that showed a title and played a sound in the onStep event. Since this event is triggered every tick when a player stands on\nthe location key of a component, we end up having a really annoying sound being played constantly. We can fix this by storing whether or not a player has stepped on this\nwin_zone component in the past. Let‚Äôs take a look:\nPlayerEvent(Join) {\n  CallFunction(__init)\n  CallFunction(createComponent, &quot;win_zone&quot;, new Location(12.5, 50.5, 69.5))\n  CallFunction(createComponent, &quot;win_zone&quot;, new Location(5.5, 50.5, 69.5))\n}\n \nFunction(&quot;win_zone:init&quot;) {\n  CreateDict(Variable(playerDict, LINE))\n  CreateList(Variable(props, LOCAL), Variable(playerDict, LINE))\n  CallFunction(setComponentProps)\n}\n \nFunction(&quot;win_zone:onStep&quot;) {\n  // Get the dictionary from the props list; it is the first element:\n  GetListValue(Variable(playerDict, LINE), Variable(props, LOCAL), 1)\n \n  If(!DictHasKey(Variable(playerDict, LINE), &quot;%default&quot;)) { // ! means NOT\n    SendTitle(&quot;&quot;, &quot;&lt;#8cb85a&gt;You win!&quot;, 20, 0, 10)\n    PlaySound(&quot;Pling&quot;, 1, 2)\n    SetDictValue(Variable(playerDict, LINE), &quot;%default&quot;, 1) // Updating the dictionary will\n                                                            // not change it in the list, so\n                                                            // we need the code block below:\n    SetListValue(Variable(props, LOCAL), 1, Variable(playerDict))\n    CallFunction(setComponentProps)\n  }\n}\n \n// üé¨ Result:\n// The title and sound will be played only once per\n// win zone for each player, since props are instance-specific.\n\n\n                  \n                  Viewing Examples Live \n                  \n                \n\nFor a better experience, run @e3 to view the example above on plot 60983\n\n\nNext Steps\nYou now understand the basics of the declarative library. For more advanced usage, check out the other pages via the explorer on the left! Maybe look into the Key Change Pattern next?"},"cleanup":{"title":"Component Cleanup","links":[],"tags":[],"content":"\n\n                  \n                  Todo\n                  \n                \n\nThis part of the documentation still needs to be written üòî\r\nMaybe make a PR?\n\n"},"events":{"title":"Events List","links":[],"tags":[],"content":"This is a comprehensive list of all events called by the declarative library:\nEntity events\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDF EventComponent EventDeletes ComponentEntityDmgEntityonHurtDamageEntityonHurtEntityDeathonDeathYesClickEntityonClickEntityKillMobonKilledYes\nBlock/Location events\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDF EventComponent EventRightClickonRightClickLeftClickonLeftClickN/AonStep"},"index":{"title":"Welcome to the Declarative Library","links":["basics"],"tags":[],"content":"The declarative library aims to make coding in DiamondFire inherently more declarative (and thus reusable) by introducing abstractions known as components. These components are oftentimes analogous to classes, but most closely represent and are inspired by those from React.js.\nGet started by learning the basics"},"key-change":{"title":"Key Change Pattern","links":["advanced/advanced-components"],"tags":[],"content":"Oftentimes, a component will be comprised of a set of entities. For instance, you may want to create a component that represents a merchant villager in your world. To keep\r\neverything declarative, you need to spawn the villager when the component is created, probably through the init event. Here arises a common problem: What should we pass\r\nas the key to the component if the villager isn‚Äôt spawned yet? We want to use events that are only available to components with a UUID key, but we don‚Äôt have the UUID of\r\nthe villager until it has spawned.\nThe solution is to pass a location key as usual, and spawn the villager at that location. Then, you can change the key of the component from within the init event thread\r\nusing the setComponentKey function:\nFunction(&quot;merchant:init&quot;) {\n  SpawnMob(SpawnEgg(Villager), Variable(loc, LOCAL))\n  SetAI(None)\n  CallFunction(setComponentKey, GameValue(UUID, LastEntity))\n}\nNext Steps\nNow that you understand this basic pattern, try looking into Advanced Components next!"}}